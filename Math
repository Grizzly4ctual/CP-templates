class Math{
private:
    const int MOD=1e9+7;        //change mod if required!
    int fac[200005];
public:
    bool prime[15000105];
    Math() {
        fac[0]=1;
        for (int i=2;i<200005;i++) {
            fac[i]=fac[i-1]*i;
            fac[i]%=MOD;
        }
    }
    int gcd(int a,int b) {
        if (a==0) {
            return b;
        }
        if (b==0) {
            return a;
        }
        return gcd(b,b%a);
    }
    void sieve(int n) {
        for (int i=0;i<=n;i++) {
            prime[i]=1;
        }
        for (int p=2;p*p<=n;p++) {
            if (prime[p]) {
                for (int j=p*p;j<=n;j+=p) {
                    prime[j]=0;
                }
            }
        }
        prime[1]=prime[0]=0;
    }
    int phi(int n) {
        int res=n;
        for (int i=0;primes[i]*primes[i]<=n;i++) {
            if (n%primes[i]==0) {
                res-=(res/primes[i]);
                while(n%primes[i]==0) {
                    n/=primes[i];
                }
            }
        }
        if (n>1) {
            res-=(res/n);
        }
        return res;
    }
    vector<int>primes;
    void genprimes(int n) {
        sieve(n+1);
        for (int i=2;i<n+1;i++) {
            if (prime[i]) {
                primes.push_back(i);
            }
        }
    }
    int binpowMod(int a,int b) {
        a%=MOD;
        int ans=1;
        while(b>0){
            if(b%2){
                ans=(ans*a)%MOD;
            }
            a=(a*a)%MOD;
            b/=2;
        }
        return ans;
    }
    int modInverse(int n) {
        return binpowMod(n, MOD-2);
    }
    int nCr(int n, int r){
        if (n<r)
            return 0;
        if (r==0 || r==n)
            return 1;
        return (fac[n] * modInverse(fac[r]) % MOD * modInverse(fac[n - r]) % MOD) % MOD;
    }
};
